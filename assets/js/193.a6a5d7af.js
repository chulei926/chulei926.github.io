(window.webpackJsonp=window.webpackJsonp||[]).push([[193],{555:function(a,t,r){"use strict";r.r(t);var _=r(22),v=Object(_.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"简介"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[a._v("#")]),a._v(" 简介")]),a._v(" "),r("h2",{attrs:{id:"_1-定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-定义"}},[a._v("#")]),a._v(" 1. 定义")]),a._v(" "),r("p",[a._v("Kafka 是一个"),r("strong",[a._v("分布式")]),a._v("的基于"),r("strong",[a._v("发布/订阅模式")]),a._v("的消息队列（Message Queue） ， 主要应用于"),r("strong",[a._v("大数据实时处理")]),a._v("领域。")]),a._v(" "),r("h2",{attrs:{id:"_2-消息队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-消息队列"}},[a._v("#")]),a._v(" 2. 消息队列")]),a._v(" "),r("h3",{attrs:{id:"_2-1-好处"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-好处"}},[a._v("#")]),a._v(" 2.1 好处")]),a._v(" "),r("ul",[r("li",[a._v("解耦")]),a._v(" "),r("li",[a._v("异步")]),a._v(" "),r("li",[a._v("缓冲")]),a._v(" "),r("li",[a._v("削峰")])]),a._v(" "),r("h3",{attrs:{id:"_2-2-消息队列的两种模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-消息队列的两种模式"}},[a._v("#")]),a._v(" 2.2 消息队列的两种模式")]),a._v(" "),r("h4",{attrs:{id:"a-点对点模式-一对一-消费者主动拉取数据-消息收到后消息清除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#a-点对点模式-一对一-消费者主动拉取数据-消息收到后消息清除"}},[a._v("#")]),a._v(" a. 点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）")]),a._v(" "),r("p",[a._v("消息生产者发送消息到 Quaua 中，然后消息消费者从 Quaua 中取出并消费消息。消息被消费以后，Quaua 中不再存储，所以消息消费者不可能消费到已经被消费的消息。Quaua 支持存在多个消费者，但是对一个消息而言，只有一个消费者可以消费。"),r("br"),a._v(" "),r("img",{attrs:{src:"/images/bigData/kafka/%E7%82%B9%E5%AF%B9%E7%82%B9%E6%B6%88%E6%81%AF.png",alt:"点对点消息"}})]),a._v(" "),r("h4",{attrs:{id:"b-发布-订阅模式-一对多-消费者消费数据之后不会清除消息"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#b-发布-订阅模式-一对多-消费者消费数据之后不会清除消息"}},[a._v("#")]),a._v(" b. 发布/订阅模式（一对多，消费者消费数据之后不会清除消息）")]),a._v(" "),r("p",[a._v("消息生产者（发布）将消息发布到 topic 中，同时有多个消费者（订阅）消费消息。和点对点方式不同，发布到 topic 的消息会被所有的订阅者消费。"),r("br"),a._v(" "),r("img",{attrs:{src:"/images/bigData/kafka/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85.png",alt:"发布订阅"}})]),a._v(" "),r("h2",{attrs:{id:"kafka架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#kafka架构"}},[a._v("#")]),a._v(" kafka架构")]),a._v(" "),r("p",[r("img",{attrs:{src:"/images/bigData/kafka/%E6%9E%B6%E6%9E%84.png",alt:"架构"}})]),a._v(" "),r("ol",[r("li",[a._v("Producer：生产者，就是向 kafka broker 发送消息的客户端")]),a._v(" "),r("li",[a._v("Consumer：消费者，从 kafka broker 拉取消息的客户端")]),a._v(" "),r("li",[a._v("Consumer Group：消费者组，由多个 consumer 组成。"),r("strong",[a._v("组内的每个消费者负责消费不同分区的消息，一个分区只能由一个组内的消费者消费。消费者组之间互不影响")]),a._v("。所有的消费者都属于某个消费者组，即"),r("strong",[a._v("消费者组是逻辑上的一个订阅者")])]),a._v(" "),r("li",[a._v("Broker：一个kafka部署节点（机器）就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic")]),a._v(" "),r("li",[a._v("Topic：一个队列，生产者和消费者面向的都是一个 topic")]),a._v(" "),r("li",[a._v("Partition：为了实现扩展性，一个非常大的 topic 可以分布在多个 broker 上，"),r("strong",[a._v("一个 topic 可以分为多个 partition")]),a._v("，"),r("strong",[a._v("每个 partition 是一个有序的队列")])]),a._v(" "),r("li",[a._v("Replica：副本。为保证集群中某个节点发生故障时，该节点上的 partition 数据不丢失，且 kafka 能够继续工作，kafka 提供了副本机制，"),r("strong",[a._v("一个 topic 的每个分区都有若干个副本")]),a._v("，一个 leader 和 若干个 follower")]),a._v(" "),r("li",[a._v("leader：每个分区多个"),r("strong",[a._v("副本的主节点")]),a._v("，生产者发送数据的对象，以及消费者消费数据的对象 都是 leader")]),a._v(" "),r("li",[a._v("follower：每个分区多个"),r("strong",[a._v("副本中的从节点")]),a._v("，实时的从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 会成为新的 leader")])])])}),[],!1,null,null,null);t.default=v.exports}}]);