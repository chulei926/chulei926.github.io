(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{378:function(a,t,_){"use strict";_.r(t);var v=_(22),r=Object(v.a)({},(function(){var a=this,t=a.$createElement,_=a._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"io模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#io模型"}},[a._v("#")]),a._v(" IO模型")]),a._v(" "),_("h2",{attrs:{id:"_1-java-bio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-java-bio"}},[a._v("#")]),a._v(" 1. Java BIO")]),a._v(" "),_("p",[_("img",{attrs:{src:"/images/netty/JavaBIO.png",alt:"传统的服务设计模式"}})]),a._v(" "),_("p",[_("strong",[a._v("同步并阻塞")]),a._v("(传统阻塞型)，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销")]),a._v(" "),_("h2",{attrs:{id:"_1-1-bio-流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-bio-流程"}},[a._v("#")]),a._v(" 1.1 bio 流程")]),a._v(" "),_("ol",[_("li",[a._v("服务器端启动一个ServerSocket")]),a._v(" "),_("li",[a._v("客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯")]),a._v(" "),_("li",[a._v("客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝")]),a._v(" "),_("li",[a._v("如果有响应，客户端线程会等待请求结束后，在继续执行")])]),a._v(" "),_("h2",{attrs:{id:"_1-2-bio-问题分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-bio-问题分析"}},[a._v("#")]),a._v(" 1.2 bio 问题分析")]),a._v(" "),_("ol",[_("li",[a._v("每个请求都需要创建独立的线程，与对应的客户端进行数据Read、业务处理、数据Write。")]),a._v(" "),_("li",[a._v("当并发数较大时，需要创建大量的线程来处理连接，系统资源占用较大。")]),a._v(" "),_("li",[a._v("连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。")])]),a._v(" "),_("h2",{attrs:{id:"_2-java-nio"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-java-nio"}},[a._v("#")]),a._v(" 2. Java NIO")]),a._v(" "),_("p",[_("img",{attrs:{src:"/images/netty/overview-selectors.png",alt:"overview-selectors"}})]),a._v(" "),_("p",[_("strong",[a._v("同步非阻塞")]),a._v("，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理")]),a._v(" "),_("h2",{attrs:{id:"_2-1-特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-特点"}},[a._v("#")]),a._v(" 2.1 特点")]),a._v(" "),_("ol",[_("li",[a._v("NIO是 面向缓冲区 ，或者面向 块 编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络")]),a._v(" "),_("li",[a._v("Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。")])]),a._v(" "),_("h2",{attrs:{id:"_2-2-nio-有三大核心部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-nio-有三大核心部分"}},[a._v("#")]),a._v(" 2.2 NIO 有三大核心部分：")]),a._v(" "),_("ol",[_("li",[a._v("Channel(通道)")]),a._v(" "),_("li",[a._v("Buffer(缓冲区)")]),a._v(" "),_("li",[a._v("Selector(选择器)")])]),a._v(" "),_("h2",{attrs:{id:"_2-3-应用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-应用"}},[a._v("#")]),a._v(" 2.3 应用：")]),a._v(" "),_("p",[a._v("HTTP2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。")]),a._v(" "),_("h2",{attrs:{id:"_2-4-nio-和-bio-的比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-nio-和-bio-的比较"}},[a._v("#")]),a._v(" 2.4 NIO 和 BIO 的比较")]),a._v(" "),_("ol",[_("li",[a._v("BIO 以流的方式处理数据,而 NIO 以块的方式处理数据,块 I/O 的效率比流 I/O 高很多")]),a._v(" "),_("li",[a._v("BIO 是阻塞的，NIO 则是非阻塞的")]),a._v(" "),_("li",[a._v("BIO基于字节流和字符流进行操作，而 NIO 基于 Channel(通道)和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道")])]),a._v(" "),_("h2",{attrs:{id:"_3-java-aio-nio-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-java-aio-nio-2"}},[a._v("#")]),a._v(" 3. Java AIO(NIO.2)")]),a._v(" "),_("p",[_("strong",[a._v("异步非阻塞")]),a._v("，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用")])])}),[],!1,null,null,null);t.default=r.exports}}]);