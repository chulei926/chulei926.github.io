(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{520:function(s,e,a){"use strict";a.r(e);var t=a(22),r=Object(t.a)({},(function(){var s=this,e=s.$createElement,a=s._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"dockerfile指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile指令"}},[s._v("#")]),s._v(" Dockerfile指令")]),s._v(" "),a("h2",{attrs:{id:"from-指定基础镜像"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from-指定基础镜像"}},[s._v("#")]),s._v(" FROM 指定基础镜像")]),s._v(" "),a("ul",[a("li",[s._v("所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。")]),s._v(" "),a("li",[s._v("一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。")])]),s._v(" "),a("p",[s._v("除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("FROM scratch\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[s._v("如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。"),a("br"),s._v("\n不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、etcd。"),a("br"),s._v("\n对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。"),a("br"),s._v("\n使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。")]),s._v(" "),a("h2",{attrs:{id:"run-执行命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#run-执行命令"}},[s._v("#")]),s._v(" RUN 执行命令")]),s._v(" "),a("p",[s._v("RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：")]),s._v(" "),a("ul",[a("li",[s._v("shell 格式：RUN <命令>，就像直接在命令行中输入的命令一样。"),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("RUN "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v("'<h1>Hello, Docker!</h1>'")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" /usr/share/nginx/html/index.html\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])]),s._v(" "),a("li",[s._v('exec 格式：RUN ["可执行文件", "参数1", "参数2"]，这更像是函数调用中的格式。'),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])])]),s._v(" "),a("h2",{attrs:{id:"copy-复制文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copy-复制文件"}},[s._v("#")]),s._v(" COPY 复制文件")]),s._v(" "),a("p",[s._v("格式：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("COPY [--chown=<user>:<group>] <源路径>... <目标路径>")])]),s._v(" "),a("li",[a("code",[s._v('COPY [--chown=<user>:<group>] ["<源路径1>",... "<目标路径>"]')])])]),s._v(" "),a("blockquote",[a("p",[s._v("和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。")])]),s._v(" "),a("p",[s._v("COPY 指令将从构建上下文目录中 <源路径> 的文件/目录复制到新的一层的镜像内的 <目标路径> 位置。比如："),a("br")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("COPY package.json /usr/src/app/\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("code",[s._v("<源路径>")]),s._v(" 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如："),a("br")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("COPY hom* /mydir/\nCOPY hom?.txt /mydir/\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br")])]),a("p",[a("code",[s._v("<目标路径>")]),s._v(" 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。")]),s._v(" "),a("p",[s._v("此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。")]),s._v(" "),a("p",[s._v("在使用该指令的时候还可以加上 "),a("code",[s._v("--chown=<user>:<group>")]),s._v(" 选项来改变文件的所属用户及所属组。")]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v("COPY --chown=55:mygroup files* /mydir/\nCOPY --chown=bin files* /mydir/\nCOPY --chown=1 files* /mydir/\nCOPY --chown=10:11 files* /mydir/\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"add-更高级的复制文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#add-更高级的复制文件"}},[s._v("#")]),s._v(" ADD 更高级的复制文件")]),s._v(" "),a("p",[a("code",[s._v("ADD")]),s._v(" 指令和 "),a("code",[s._v("COPY")]),s._v(" 的格式和性质基本一致。但是在 "),a("code",[s._v("COPY")]),s._v(" 基础上增加了一些功能。")]),s._v(" "),a("p",[s._v("比如 <源路径> 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <目标路径> 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。")]),s._v(" "),a("p",[s._v("如果 <源路径> 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 <目标路径> 去。")]),s._v(" "),a("p",[s._v("在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("FROM scratch\nADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v(".\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("p",[s._v("但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。")]),s._v(" "),a("p",[s._v("在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。")]),s._v(" "),a("p",[s._v("另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。")]),s._v(" "),a("p",[s._v("因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。")]),s._v(" "),a("p",[s._v("在使用该指令的时候还可以加上 "),a("code",[s._v("--chown=<user>:<group>")]),s._v(" 选项来改变文件的所属用户及所属组。")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("ADD --chown"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("55")]),s._v(":mygroup files* /mydir/\nADD --chown"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("bin files* /mydir/\nADD --chown"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" files* /mydir/\nADD --chown"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),s._v(":11 files* /mydir/\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("h2",{attrs:{id:"cmd-容器启动命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cmd-容器启动命令"}},[s._v("#")]),s._v(" CMD 容器启动命令")]),s._v(" "),a("p",[s._v("CMD 指令的格式和 RUN 相似，也是两种格式：")]),s._v(" "),a("ul",[a("li",[s._v("shell 格式："),a("code",[s._v("CMD <命令>")])]),s._v(" "),a("li",[s._v("exec 格式："),a("code",[s._v('CMD ["可执行文件", "参数1", "参数2"...]')])]),s._v(" "),a("li",[s._v('参数列表格式：CMD ["参数1", "参数2"...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。')])]),s._v(" "),a("p",[s._v("Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。")]),s._v(" "),a("p",[s._v("在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 "),a("code",[s._v("/bin/bash")]),s._v("，如果我们直接 "),a("code",[s._v("docker run -it ubuntu")]),s._v(" 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 "),a("code",[s._v("docker run -it ubuntu cat /etc/os-release")]),s._v("。这就是用 "),a("code",[s._v("cat /etc/os-release")]),s._v(" 命令替换了默认的 "),a("code",[s._v("/bin/bash")]),s._v(" 命令了，输出了系统版本信息。")]),s._v(" "),a("p",[s._v('在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 "，而不要使用单引号。')]),s._v(" "),a("p",[s._v("如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("CMD "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("echo")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token environment constant"}},[s._v("$HOME")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("在实际执行中，会将其变更为：")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[s._v("CMD "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"sh"')]),s._v(", "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"-c"')]),s._v(", "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"echo '),a("span",{pre:!0,attrs:{class:"token environment constant"}},[s._v("$HOME")]),s._v('"')]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("这就是为什么可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。")]),s._v(" "),a("h2",{attrs:{id:"entrypoint-入口点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entrypoint-入口点"}},[s._v("#")]),s._v(" ENTRYPOINT 入口点")]),s._v(" "),a("p",[s._v("ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。")]),s._v(" "),a("p",[s._v("ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 "),a("code",[s._v("docker run")]),s._v(" 的参数 "),a("code",[s._v("--entrypoint")]),s._v(" 来指定。")]),s._v(" "),a("p",[s._v("当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：")]),s._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("ENTRYPOINT"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"<CMD>"')]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])])])}),[],!1,null,null,null);e.default=r.exports}}]);