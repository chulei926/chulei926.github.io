(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{401:function(v,_,t){"use strict";t.r(_);var s=t(22),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"jvm架构模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm架构模型"}},[v._v("#")]),v._v(" jvm架构模型")]),v._v(" "),t("p",[t("img",{attrs:{src:"/images/jvm/jvm%E6%9E%B6%E6%9E%84.png",alt:"jvm架构"}})]),v._v(" "),t("p",[v._v("Java编译器输入的指令流基本上是一种"),t("strong",[v._v("基于栈的指令集架构")]),v._v("，另外一种指令集架构则是"),t("strong",[v._v("基于寄存器的指令集架构")]),v._v("。")]),v._v(" "),t("p",[v._v("具体来说，这两种架构之间的区别：")]),v._v(" "),t("ul",[t("li",[v._v("基于栈架构的特点\n"),t("ol",[t("li",[v._v("设计和实现简单，适用于资源受限的系统。")]),v._v(" "),t("li",[v._v("避开了寄存器的分配难题，使用零地址指令方式分配。")]),v._v(" "),t("li",[v._v("指令流中的指令大部分是零地址指令，器质性过程愈来愈操作栈。指令集更小，编译器容易实现。")])])]),v._v(" "),t("li",[v._v("基于寄存器架构的特点\n"),t("ol",[t("li",[v._v("典型的应用用x86的二进制指令集，比如传统的PC以及Android的Davlik虚拟机。")]),v._v(" "),t("li",[v._v("指令集架构则完全依赖于硬件，可移植性差。")]),v._v(" "),t("li",[v._v("性能优秀和执行更高效。")]),v._v(" "),t("li",[v._v("话费更少的指令与完成一项操作。")]),v._v(" "),t("li",[v._v("在大部分的情况下，基于寄存器架构的指令集往往都已一地址指令、二地址指令和三地址指令为主，儿基于栈的架构指令集却是以零地址指令为主。")])])])]),v._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),t("p",[t("strong",[v._v("由于跨平台性的设计，Java的指令都是根据栈来设计的。")]),v._v("\n不同平台CPU架构不同，所以不能设计成基于寄存器的。")]),v._v(" "),t("p",[v._v("优点是"),t("strong",[v._v("跨平台")]),v._v("、"),t("strong",[v._v("指令集小")]),v._v("，"),t("strong",[v._v("编译器容易实现")]),v._v("。")]),v._v(" "),t("p",[v._v("缺点是"),t("strong",[v._v("性能下降")]),v._v("，"),t("strong",[v._v("实现同样的功能需要更多的指令")]),v._v("。")])])}),[],!1,null,null,null);_.default=r.exports}}]);